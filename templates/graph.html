<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Gráfico de Precios</title>
  <!-- Importar Plotly -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <!-- Tu CSS principal -->
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    .graph-container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    #graphDiv {
      width: 100%;
      height: 600px;
    }
    .button-container {
      text-align: center;
      margin-top: 20px;
    }
    .btn {
      padding: 8px 16px;
      background-color: #ccc;
      text-decoration: none;
      color: #000;
      border-radius: 4px;
    }
    .btn:hover {
      background-color: #aaa;
    }
    /* Estilos para el tooltip personalizado */
    #customTooltip {
      position: absolute;
      display: none;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 100;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>MercadoX5</h1>
    <h2>Gráfico de Precios</h2>

    <div class="graph-container">
      <!-- Contenedor donde se dibujará la gráfica -->
      <div id="graphDiv"></div>
    </div>

    <div class="button-container">
      <!-- Botón para volver al home (ajusta la ruta si es necesario) -->
      <a href="/" class="btn">Volver</a>
    </div>
  </div>

  <!-- Contenedor para el tooltip personalizado -->
  <div id="customTooltip"></div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // "jsonData" se pasa desde Flask como 'data' en render_template
      const jsonData = {{ data|tojson|safe }};
      
      if (!jsonData || !jsonData.data || !Array.isArray(jsonData.data) || jsonData.data.length === 0) {
        console.warn("No hay series de datos para graficar.");
        document.getElementById("graphDiv").innerHTML = "<p>No se encontraron datos para este gráfico.</p>";
        return;
      }
      
      // Ordenar las series según el último precio (descendente)
      let sortedData = jsonData.data.map(item => {
        const lastPrice = item.prices[item.prices.length - 1];
        return { originalData: item, lastPrice: lastPrice };
      });
      sortedData.sort((a, b) => b.lastPrice - a.lastPrice);
      
      // Construir las trazas de Plotly (se desactiva el tooltip incorporado)
      const traces = sortedData.map(itemObj => {
        const item = itemObj.originalData;
        return {
          x: item.dates, // Se asume que las fechas vienen en formato "YYYY-MM-DD"
          y: item.prices,
          mode: 'lines+markers',
          name: item.label,
          hoverinfo: 'none'  // Desactiva el tooltip incorporado
        };
      });
      
      // Configuración del layout; se desactiva el hover integrado (hovermode: false)
      const layout = {
        title: {
          text: jsonData.title || "Gráfico de Precios",
          font: { size: 20 }
        },
        xaxis: {
          title: { text: 'Fecha', standoff: 30 },
          tickangle: -45,
          tickformat: '%b %d, %Y',
          automargin: true
        },
        yaxis: {
          title: 'Precio',
          tickformat: '.2f'
        },
        showlegend: true,
        legend: {
          x: 0,
          y: -0.5,
          orientation: 'h',
          yanchor: 'top'
        },
        hovermode: false,  // Desactivamos el tooltip incorporado
        margin: {
          l: 80,
          r: 50,
          t: 100,
          b: 200
        }
      };
      
      const config = {
        responsive: true,
        displayModeBar: true,
        displaylogo: false
      };
      
      // Renderizamos el gráfico
      Plotly.newPlot('graphDiv', traces, layout, config).then(function(gd) {
        const graphDiv = document.getElementById('graphDiv');
        const customTooltip = document.getElementById('customTooltip');
        
        // Función para convertir una fecha en formato "YYYY-MM-DD" a milisegundos
        function dateStrToMs(dateStr) {
          return Date.parse(dateStr);
        }
        
        // Obtenemos la información del eje x a partir del layout interno
        // gd._fullLayout.xaxis.range es un arreglo con [xmin, xmax] en valores numéricos (ms)
        const xRange = gd._fullLayout.xaxis.range;  // Ej: [xmin, xmax] en milisegundos
        const xAxisOffset = gd._fullLayout.xaxis._offset;  // Desplazamiento en píxeles del área de trazado
        const plotWidth = gd._fullLayout.xaxis._length;  // Ancho del área de trazado en píxeles
        
        // Agregamos un evento mousemove sobre el contenedor del gráfico
        graphDiv.addEventListener('mousemove', function(evt) {
          const bb = graphDiv.getBoundingClientRect();
          const mouseX = evt.clientX - bb.left;
          
          // Verificar que el mouse esté dentro del área de trazado
          if (mouseX < xAxisOffset || mouseX > (xAxisOffset + plotWidth)) {
            customTooltip.style.display = 'none';
            return;
          }
          
          // Calcular la posición relativa en el área de trazado
          const frac = (mouseX - xAxisOffset) / plotWidth;
          // Calcular el valor de x en el espacio de datos (en milisegundos)
          const xDataMs = xRange[0] + frac * (xRange[1] - xRange[0]);
          
          // Para cada traza, buscamos el punto cuyo valor de x (convertido a ms) esté más cercano a xDataMs
          let pointsAtX = [];
          traces.forEach(function(trace) {
            let bestIdx = null;
            let bestDiff = Infinity;
            for (let i = 0; i < trace.x.length; i++) {
              const tMs = dateStrToMs(trace.x[i]);
              const diff = Math.abs(tMs - xDataMs);
              if (diff < bestDiff) {
                bestDiff = diff;
                bestIdx = i;
              }
            }
            // Si la diferencia es menor a un umbral (por ejemplo, 1 día = 86,400,000 ms), incluimos el punto
            if (bestIdx !== null && bestDiff < 86400000) {
              pointsAtX.push({
                name: trace.name,
                y: Number(trace.y[bestIdx])
              });
            }
          });
          
          if (pointsAtX.length === 0) {
            customTooltip.style.display = 'none';
            return;
          }
          
          // Ordenar los puntos por precio de menor a mayor
          pointsAtX.sort((a, b) => a.y - b.y);
          
          // Convertir xDataMs a fecha en formato YYYY-MM-DD
          const hoveredDate = new Date(xDataMs);
          const hoveredDateStr = hoveredDate.toISOString().split('T')[0];
          
          // Construir el contenido del tooltip
          let tooltipContent = "<b>" + hoveredDateStr + "</b><br>";
          pointsAtX.forEach(function(pt) {
            tooltipContent += pt.name + ": " + pt.y.toFixed(2) + "<br>";
          });
          customTooltip.innerHTML = tooltipContent;
          customTooltip.style.display = 'block';
          customTooltip.style.left = (evt.clientX + 10) + "px";
          customTooltip.style.top = (evt.clientY + 10) + "px";
        });
        
        // Ocultar el tooltip cuando el mouse sale del área del gráfico
        graphDiv.addEventListener('mouseout', function(evt) {
          customTooltip.style.display = 'none';
        });
      });
      
      // Redimensionar la gráfica cuando la ventana cambie de tamaño
      window.addEventListener('resize', function() {
        Plotly.Plots.resize('graphDiv');
      });
    });
  </script>
</body>
</html>
