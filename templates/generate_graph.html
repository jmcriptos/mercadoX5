{% extends "base.html" %}

{% block title %}Generar Gráfico{% endblock %}

{% block content %}
<div class="container">
  <div class="page-title">
    <i class="fas fa-chart-line"></i>
    <h1>Generar Gráfico</h1>
  </div>

  {% if not current_user.is_authenticated %}
  <div class="alert alert-warning" role="alert">
    <i class="fas fa-exclamation-triangle"></i>
    Debe iniciar sesión para generar gráficos.
    <a href="{{ url_for('login', next=request.path) }}" class="alert-link">Iniciar sesión</a>
  </div>
  {% endif %}

  <form id="graphForm" class="card" method="POST" action="/generate_graph">
    <div class="form-row">
      <div class="form-group">
        <label for="start_date">Fecha de inicio:</label>
        <input type="date" id="start_date" name="start_date" required>
      </div>
      <div class="form-group">
        <label for="end_date">Fecha de fin:</label>
        <input type="date" id="end_date" name="end_date" required>
      </div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label for="product_search">Nombre del producto:</label>
        <div class="search-container">
          <input 
            type="text" 
            id="product_search" 
            class="search-input awesomplete" 
            placeholder="Buscar producto..." 
            autocomplete="off"
          >
          <input type="hidden" id="product_name" name="product_name" required>
        </div>
      </div>

      <div class="form-group">
        <label for="brand">Marca:</label>
        <select id="brand" name="brand">
          <option value="all">Todas</option>
          {% for b in all_brands %}
          <option value="{{ b }}">{{ b }}</option>
          {% endfor %}
        </select>
      </div>
    </div>

    <div class="form-row">
      <div class="form-group">
        <label for="store">Tienda:</label>
        <select id="store" name="store">
          <option value="all">Todas</option>
          {% for s in stores %}
          <option value="{{ s.id }}">{{ s.name }}</option>
          {% endfor %}
        </select>
      </div>
      <div class="form-group">
        <label for="presentation">Presentación:</label>
        <select id="presentation" name="presentation" required>
          <option value="all">Todas</option>
          {% for p in all_presentations %}
          <option value="{{ p }}">{{ p }}</option>
          {% endfor %}
        </select>
      </div>
    </div>

    <button type="submit" class="btn-primary">Generar Gráfico</button>
  </form>

  <div class="graph-container card">
    <div id="loadingMessage" style="display:none;">Cargando gráfico...</div>
    <div id="graphDiv"></div>
    <div class="button-container">
      <button id="downloadButton" class="btn-secondary" style="display:none;">Descargar como imagen</button>
    </div>
  </div>

  <div id="errorContainer" style="display:none;" class="alert alert-danger">
    <p id="errorMessage"></p>
  </div>
</div>

<div id="customTooltip"></div>

<style>
/* -- Ajustes generales, tarjetas, etc. -- */
.container {
  max-width: 1200px; 
  margin: 0 auto;
  padding: 20px;
}

.card {
  background: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
  width: 100%;
}

.page-title {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}

.page-title i {
  font-size: 24px;
}

/* -- Formulario -- */
.form-row {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
}
.form-group {
  flex: 1;
  min-width: 220px;
  margin-bottom: 15px;
}
.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
}
input[type="date"],
select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}

/* -- Buscador Awesomplete -- */
.search-container {
  position: relative;
  width: 100%;
}
.search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}
.search-input:focus {
  outline: none;
  border-color: #1a73e8;
  box-shadow: 0 0 0 3px rgba(26,115,232,0.2);
}
div.awesomplete {
  position: relative !important;
  display: block !important;
  width: 100% !important;
}
div.awesomplete > ul {
  position: absolute !important;
  left: 0 !important;
  top: calc(100% + 5px) !important;
  min-width: 100%;
  background: white !important;
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 6px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.08);
  margin: 0;
  padding: 0;
  list-style: none;
  z-index: 1000;
}
div.awesomplete > ul > li:first-child {
  background-color: #2c3e50 !important;
  color: white !important;
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
  border-left-color: #2c3e50 !important;
}
div.awesomplete > ul > li:not(:first-child) {
  background-color: white !important;
  color: black !important;
}
div.awesomplete > ul > li:hover:not(:first-child),
div.awesomplete > ul > li[aria-selected="true"]:not(:first-child) {
  background-color: #f8f9fa !important;
  border-left-color: #1a73e8;
}

/* -- Botones -- */
.btn-primary {
  background-color: #1a73e8;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 15px;
}
.btn-primary:hover {
  background-color: #1557b0;
}
.btn-secondary {
  background-color: green;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 15px;
}
.btn-secondary:hover {
  background-color: blue;
}

/* -- Gráfico -- */
.graph-container {
  margin-bottom: 20px;
}
#graphDiv {
  display: block;
  width: 95%;
  margin: 0 auto;
  height: 600px;
  border: 1px solid #eee;
  box-sizing: border-box;
}
.button-container {
  text-align: center;
  margin-top: 20px;
}
#loadingMessage {
  text-align: center;
  padding: 20px;
  font-size: 16px;
  font-weight: 500;
}

/* -- Alertas -- */
.alert {
  padding: 15px;
  border-radius: 4px;
  margin-bottom: 20px;
}
.alert-danger {
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  color: #721c24;
}
.alert-warning {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #856404;
}

/* -- Tooltip personalizado -- */
#customTooltip {
  display: none;
  position: absolute;
  background: white;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  z-index: 1000;
  pointer-events: none;
  min-width: 200px;
}
</style>
{% endblock %}

{% block scripts %}
<!-- Awesomplete y Plotly -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.css">
<script src="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  initializeDates();
  setupProductSearch();
  setupForm();
  setupDownloadButton();
  setupBrandChange();
});

/**
 * Fechas por defecto
 */
function initializeDates() {
  const today = new Date();
  const thirtyDaysAgo = new Date(today);
  thirtyDaysAgo.setDate(today.getDate() - 30);
  
  document.getElementById('end_date').value = today.toISOString().split('T')[0];
  document.getElementById('start_date').value = thirtyDaysAgo.toISOString().split('T')[0];
}

/**
 * Configura Awesomplete
 */
function setupProductSearch() {
  const searchInput = document.getElementById('product_search');
  const hiddenInput = document.getElementById('product_name');
  
  let products = {{ products|tojson|safe }};
  let uniqueProducts = Array.from(new Set(products));
  
  let awesomplete = new Awesomplete(searchInput, {
    minChars: 1,
    maxItems: 10,
    autoFirst: true,
    list: uniqueProducts
  });

  searchInput.addEventListener('awesomplete-selectcomplete', function() {
    hiddenInput.value = searchInput.value;
    fetch(`/get_brands_for_product?product_name=${encodeURIComponent(searchInput.value)}`)
      .then(response => response.json())
      .then(data => {
        updateFilters(data);
      })
      .catch(error => console.error('Error al obtener filtros:', error));
  });
}

/**
 * Actualiza selects de marca y presentación
 */
function updateFilters(data) {
  const brandSelect = document.getElementById('brand');
  brandSelect.innerHTML = '<option value="all">Todas</option>';
  data.brands.forEach(brand => {
    const option = document.createElement('option');
    option.value = brand;
    option.textContent = brand;
    brandSelect.appendChild(option);
  });
  
  const presentationSelect = document.getElementById('presentation');
  presentationSelect.innerHTML = '<option value="all">Todas</option>';
  data.presentations.forEach(presentation => {
    const option = document.createElement('option');
    option.value = presentation;
    option.textContent = presentation;
    presentationSelect.appendChild(option);
  });
}

/**
 * Cuando cambia la marca, actualizar presentaciones
 */
function setupBrandChange() {
  const brandSelect = document.getElementById('brand');
  brandSelect.addEventListener('change', function() {
    const selectedBrand = this.value;
    const productName = document.getElementById('product_name').value;
    
    if (selectedBrand !== "all") {
      fetch(`/get_presentations?product_name=${encodeURIComponent(productName)}&brand=${encodeURIComponent(selectedBrand)}`)
        .then(response => response.json())
        .then(data => {
          const presentationSelect = document.getElementById('presentation');
          presentationSelect.innerHTML = '<option value="all">Todas</option>';
          data.presentations.forEach(presentation => {
            const option = document.createElement('option');
            option.value = presentation;
            option.textContent = presentation;
            presentationSelect.appendChild(option);
          });
        })
        .catch(error => console.error('Error al obtener presentaciones:', error));
    } else {
      fetch(`/get_brands_for_product?product_name=${encodeURIComponent(productName)}`)
        .then(response => response.json())
        .then(data => {
          const presentationSelect = document.getElementById('presentation');
          presentationSelect.innerHTML = '<option value="all">Todas</option>';
          data.presentations.forEach(presentation => {
            const option = document.createElement('option');
            option.value = presentation;
            option.textContent = presentation;
            presentationSelect.appendChild(option);
          });
        })
        .catch(error => console.error('Error al actualizar presentaciones:', error));
    }
  });
}

/**
 * Maneja envío del formulario
 */
function setupForm() {
  const form = document.getElementById('graphForm');
  form.addEventListener('submit', async function(event) {
    event.preventDefault();
    
    const formData = new FormData(this);
    if (formData.get('start_date') > formData.get('end_date')) {
      showError('La fecha de inicio no puede ser mayor a la fecha de fin.');
      return;
    }
    
    const loadingMessage = document.getElementById('loadingMessage');
    const graphDiv = document.getElementById('graphDiv');
    
    try {
      loadingMessage.style.display = 'block';
      graphDiv.style.display = 'none';
      
      const response = await fetch('/generate_graph', {
        method: 'POST',
        body: formData
      });
      
      if (response.redirected && response.url.includes('/login')) {
        showError('Debe iniciar sesión para generar gráficos. Redirigiendo...');
        setTimeout(() => {
          window.location.href = response.url;
        }, 2000);
        return;
      }
      
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Error en la respuesta del servidor');
      }
      
      loadingMessage.style.display = 'none';
      graphDiv.style.display = 'block';
      
      createPlot(data);
      document.getElementById('downloadButton').style.display = 'block';
      
    } catch (error) {
      console.error('Error:', error);
      showError(error.message);
      loadingMessage.style.display = 'none';
    }
  });
}

/**
 * Botón para descargar imagen del gráfico
 */
function setupDownloadButton() {
  document.getElementById('downloadButton').addEventListener('click', function() {
    Plotly.downloadImage('graphDiv', {
      format: 'png',
      filename: 'grafico',
      width: 1200,
      height: 800,
      scale: 2
    });
  });
}

/**
 * Crea el gráfico con línea de regresión
 */
function createPlot(data) {
  if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
    showError('No hay datos para graficar');
    return;
  }

  // Paleta de colores
  const colors = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
    '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
    '#393b79', '#637939', '#8c6d31', '#843c39', '#7b4173',
    '#17becf', '#e7969c', '#6b6ecf', '#b5cf6b', '#cedb9c',
    '#bd9e39', '#ad494a', '#d6616b', '#e7cb94', '#8ca252',
    '#d6616b', '#a55194', '#ce6dbd', '#de9ed6', '#9c9ede'
  ];

  // 1. Dibujar cada tienda como puntos
  let minPrice = Infinity;
  let maxPrice = -Infinity;
  
  // Arrays globales para la regresión
  let allDatesNum = [];  // Fechas convertidas a número
  let allPrices = [];    // Precios totales

  const traces = data.data.map((series, index) => {
    // Convertir fechas a Date y luego a número (por ejemplo, milisegundos / 1 día)
    // Podrías usar milisegundos, pero para evitar números muy grandes, a veces se divide por 86.4e6
    let numericDates = series.dates.map(d => Date.parse(d) / 86400000); // 86400000 = ms en 1 día

    // Actualizar arrays globales para la regresión
    allDatesNum = allDatesNum.concat(numericDates);
    allPrices   = allPrices.concat(series.prices);

    // Min y max
    const seriesMin = Math.min(...series.prices);
    const seriesMax = Math.max(...series.prices);
    if (seriesMin < minPrice) minPrice = seriesMin;
    if (seriesMax > maxPrice) maxPrice = seriesMax;

    return {
      x: series.dates,        // Plotly mostrará la fecha en eje X
      y: series.prices,
      mode: 'markers',        // solo puntos
      name: series.label,
      marker: {
        size: 8,
        color: colors[index % colors.length],
        line: { color: 'black', width: 1 }
      },
      hoverinfo: 'none'
    };
  });

  // 2. Calcular la recta de regresión lineal (y = m*x + b) usando allDatesNum y allPrices
  //    (Fórmulas: m = Cov(x,y)/Var(x), b = promY - m*promX)
  const { slope, intercept } = linearRegression(allDatesNum, allPrices);

  // 3. Generar puntos para la línea de regresión
  //    Tomamos el rango min -> max de "allDatesNum" para dibujar la recta en todo el rango
  const minDateNum = Math.min(...allDatesNum);
  const maxDateNum = Math.max(...allDatesNum);

  // Crear un array con algunos puntos intermedios para que la línea se vea suave
  // (por ejemplo, 50 puntos entre minDateNum y maxDateNum)
  const steps = 50;
  const stepSize = (maxDateNum - minDateNum) / steps;
  
  let regDatesNum = [];
  for (let i = 0; i <= steps; i++) {
    regDatesNum.push(minDateNum + i * stepSize);
  }

  // Calcular precios de la recta en esos puntos
  let regPrices = regDatesNum.map(xNum => slope * xNum + intercept);

  // Convertir regDatesNum a formato de fecha para que Plotly muestre la escala de tiempo
  let regDates = regDatesNum.map(num => {
    // num son "días desde 1970", volvemos a Date
    return new Date(num * 86400000).toISOString().split('T')[0];
  });

  // 4. Agregar la traza de la recta de regresión
  traces.push({
    x: regDates,
    y: regPrices,
    mode: 'lines',
    name: 'Línea de tendencia (Regresión)',
    line: {
      color: 'red',
      width: 3
    },
    hoverinfo: 'none'
  });

  // Ajustar min y max global con la línea de regresión (por si sale del rango)
  const regMin = Math.min(...regPrices);
  const regMax = Math.max(...regPrices);
  if (regMin < minPrice) minPrice = regMin;
  if (regMax > maxPrice) maxPrice = regMax;

  // 5. Definir rango de eje Y con margen
  const priceRange = maxPrice - minPrice;
  const margin = priceRange * 0.1;
  const yMin = Math.max(0, minPrice - margin);
  const yMax = maxPrice + margin;

  // 6. Configurar layout
  const layout = {
    title: { text: data.title, font: { size: 24 } },
    xaxis: {
      title: 'Fecha',
      tickangle: -45,
      automargin: true,
      showline: true,
      linecolor: 'black',
      linewidth: 2,
      gridcolor: '#e0e0e0',
      // type: 'date'  // Plotly usualmente detecta automáticamente
    },
    yaxis: {
      title: 'Precio',
      tickformat: priceRange < 0.1 ? '.3f' : '.2f',
      automargin: true,
      showline: true,
      linecolor: 'black',
      linewidth: 2,
      range: [yMin, yMax],
      nticks: priceRange < 0.1 ? 5 : 8,
      gridcolor: '#e0e0e0'
    },
    showlegend: true,
    legend: {
      x: 0,
      y: -0.3,
      orientation: 'h',
      yanchor: 'top',
      xanchor: 'left'
    },
    hovermode: 'closest',
    margin: { l: 100, r: 50, t: 100, b: 150 },
    plot_bgcolor: 'white',
    paper_bgcolor: 'white',
    autosize: true,
    height: 700
  };

  // 7. Crear el gráfico
  Plotly.newPlot('graphDiv', traces, layout, {
    responsive: true,
    displayModeBar: true,
    displaylogo: false,
    modeBarButtonsToRemove: ['lasso2d','select2d']
  }).then(gd => {
    // Evento hover para mostrar tooltip personalizado
    gd.on('plotly_hover', function(eventData) {
      const date = eventData.points[0].x;
      const pointsAtDate = [];
      gd.data.forEach(trace => {
        const pointIndex = trace.x.indexOf(date);
        if (pointIndex !== -1) {
          pointsAtDate.push({ store: trace.name, price: trace.y[pointIndex] });
        }
      });
      if (pointsAtDate.length === 0) return;
      pointsAtDate.sort((a, b) => b.price - a.price);

      const dateObj = new Date(date);
      const dateStr = dateObj.toLocaleDateString('es-VE', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });

      let content = `
        <div style="font-weight:bold; padding-bottom:5px; margin-bottom:5px; border-bottom:1px solid #ccc;">
          ${dateStr}
        </div>
      `;
      pointsAtDate.forEach(point => {
        // Evita NaN en la línea de regresión
        if (!isNaN(point.price)) {
          const decimals = priceRange < 0.1 ? 3 : 2;
          content += `<div style="padding:2px 0;">${point.store}: Bs. ${point.price.toFixed(decimals)}</div>`;
        }
      });

      const tooltip = document.getElementById('customTooltip');
      tooltip.innerHTML = content;
      tooltip.style.display = 'block';

      let x = eventData.event.pageX + 10;
      let y = eventData.event.pageY + 10;
      const rect = tooltip.getBoundingClientRect();
      if (x + rect.width > window.innerWidth) {
        x = eventData.event.pageX - rect.width - 10;
      }
      if (y + rect.height > window.innerHeight) {
        y = eventData.event.pageY - rect.height - 10;
      }
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';

      // Línea vertical punteada
      Plotly.relayout(gd, {
        shapes: [{
          type: 'line',
          x0: date,
          x1: date,
          xref: 'x',
          yref: 'paper',
          y0: 0,
          y1: 1,
          line: { dash: 'dot', color: 'red', width: 2 }
        }]
      });
    });

    // Al salir del hover
    gd.on('plotly_unhover', function() {
      document.getElementById('customTooltip').style.display = 'none';
      Plotly.relayout(gd, { shapes: [] });
    });

    // Ajuste de tamaño tras un retardo
    setTimeout(() => {
      Plotly.Plots.resize(gd);
    }, 100);
  });
}

/**
 * Función de regresión lineal simple
 * @param {number[]} xVals - Valores numéricos de X (fechas convertidas)
 * @param {number[]} yVals - Valores de Y (precios)
 * @return { slope, intercept }
 */
function linearRegression(xVals, yVals) {
  // Promedios
  const n = xVals.length;
  const meanX = xVals.reduce((a, b) => a + b, 0) / n;
  const meanY = yVals.reduce((a, b) => a + b, 0) / n;

  // Suma de productos desviaciones
  let num = 0;   // Cov(x,y)
  let den = 0;   // Var(x)
  for (let i = 0; i < n; i++) {
    const x = xVals[i] - meanX;
    const y = yVals[i] - meanY;
    num += x * y;
    den += x * x;
  }

  const slope = num / den;
  const intercept = meanY - slope * meanX;
  return { slope, intercept };
}

/**
 * Muestra error
 */
function showError(message) {
  const errorContainer = document.getElementById('errorContainer');
  const errorMessage = document.getElementById('errorMessage');
  errorMessage.textContent = message;
  errorContainer.style.display = 'block';
  setTimeout(() => {
    errorContainer.style.display = 'none';
  }, 5000);
}
</script>
{{ super() }}
{% endblock %}
























