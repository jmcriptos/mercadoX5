{% extends "base.html" %}

{% block title %}Generar Gráfico{% endblock %}

{% block content %}
<div class="container">
  <div class="page-title">
    <i class="fas fa-chart-line"></i>
    <h1>Generar Gráfico</h1>
  </div>

  {% if not current_user.is_authenticated %}
  <div class="alert alert-warning" role="alert">
    <i class="fas fa-exclamation-triangle"></i>
    Debe iniciar sesión para generar gráficos.
    <a href="{{ url_for('login', next=request.path) }}" class="alert-link">Iniciar sesión</a>
  </div>
  {% endif %}

  <!-- Formulario -->
  <form id="graphForm" class="card" method="POST" action="/generate_graph">
    
    <!-- Primera fila: Fechas -->
    <div class="form-row">
      <div class="form-group">
        <label for="start_date">Fecha de inicio:</label>
        <input type="date" id="start_date" name="start_date" required>
      </div>
      <div class="form-group">
        <label for="end_date">Fecha de fin:</label>
        <input type="date" id="end_date" name="end_date" required>
      </div>
    </div>

    <!-- Segunda fila: Búsqueda del producto -->
    <div class="form-group full-width">
      <label for="product_search" class="search-label">
          <i class="fas fa-box"></i>
          Nombre del producto:
      </label>
      <div class="search-container">
          <input type="text" 
                 id="product_search" 
                 class="search-input awesomplete" 
                 placeholder="Buscar producto..." 
                 autocomplete="off">
          <input type="hidden" 
                 id="product_name" 
                 name="product_name" 
                 required>
      </div>
  </div>

    <!-- Última fila: Selección de marcas, tiendas y presentación -->
    <div class="form-row">
      <div class="form-group">
        <label for="brand">Marcas:</label>
        <select id="brand" name="brand[]" class="form-control" multiple>
          <option value="all">Todas</option>
          {% for b in all_brands %}
          <option value="{{ b }}">{{ b }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="form-group">
        <label for="store">Tiendas:</label>
        <select id="store" name="store[]" class="form-control" multiple>
          <option value="all">Todas</option>
          {% for s in stores %}
          <option value="{{ s.id }}">{{ s.name }}</option>
          {% endfor %}
        </select>
      </div>

      <div class="form-group">
        <label for="presentation">Presentación:</label>
        <select id="presentation" name="presentation" required>
          <option value="all">Todas</option>
          {% for p in all_presentations %}
          <option value="{{ p }}">{{ p }}</option>
          {% endfor %}
        </select>
      </div>
    </div>

    <button type="submit" class="btn-primary">Generar Gráfico</button>
  </form>

  <!-- Contenedor para el gráfico y descarga -->
  <div class="graph-container card">
    <div id="loadingMessage" style="display:none;">Cargando gráfico...</div>
    <div id="graphDiv"></div>
    <div class="button-container">
      <button id="downloadButton" class="btn-secondary" style="display:none;">Descargar como imagen</button>
    </div>
  </div>

  <div id="errorContainer" style="display:none;" class="alert alert-danger">
    <p id="errorMessage"></p>
  </div>
</div>

<!-- Tooltip personalizado -->
<div id="customTooltip"></div>
{% endblock %}

{% block head_extra %}
<style>
/* Contenedor principal de formulario */
.form-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 24px;
}

/* Grupos de entrada */
.input-group {
    background: #f8f9fa;
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
}

/* Etiquetas */
.input-label {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #444;
    font-weight: 500;
    margin-bottom: 12px;
}

.input-label i {
    opacity: 0.7;
}

/* Contenedor de búsqueda */
.search-container {
    position: relative;
    width: 100%;
}

/* Entrada de búsqueda */
.search-input {
    width: 100%;
    padding: 12px 16px;
    font-size: 15px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: white;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.02);
}

.search-input:focus {
    border-color: #4285f4;
    box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
    outline: none;
}

.search-input::placeholder {
    color: #9ca3af;
}

/* Estilos Awesomplete */
.awesomplete {
    width: 100%;
}

.awesomplete > ul {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    padding: 8px 0;
    margin-top: 4px;
    width: 100%;
    max-height: 300px;
    overflow-y: auto;
}

.awesomplete > ul > li {
    padding: 8px 16px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    line-height: 1.5;
}

.awesomplete > ul > li:hover {
    background-color: #f3f4f6;
}

.awesomplete > ul > li[aria-selected="true"] {
    background-color: #e8f0fe;
    color: #1a73e8;
}

.awesomplete mark {
    background: transparent;
    color: #4285f4;
    font-weight: 500;
}

/* Controles de formulario generales */
.form-control {
    width: 100%;
    padding: 12px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background: white;
    transition: all 0.2s ease;
}

.form-control:focus {
    border-color: #4285f4;
    outline: none;
    box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.1);
}

/* Grupos de fechas */
.date-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
}

/* Grupos de filtros */
.filters-group {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 16px;
}

/* Contenedor de select */
.select-container {
    position: relative;
}

.select-container select {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding-right: 32px;
    background: white;
}

.select-container:after {
    content: '';
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid #666;
    pointer-events: none;
}

/* Botón generar */
.btn-generate {
    background: #4285f4;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    width: 100%;
    max-width: 200px;
    margin-top: 24px;
}

.btn-generate:hover {
    background: #3367d6;
    transform: translateY(-1px);
}

.btn-generate:active {
    transform: translateY(0);
}

/* Responsive */
@media (max-width: 768px) {
    .date-group {
        grid-template-columns: 1fr;
        gap: 16px;
    }

    .filters-group {
        grid-template-columns: 1fr;
    }

    .btn-generate {
        max-width: 100%;
    }
}

/* Estado de error */
.has-error .form-control,
.has-error .search-input {
    border-color: #dc3545;
}

.has-error .input-label {
    color: #dc3545;
}

.error-message {
    color: #dc3545;
    font-size: 0.875rem;
    margin-top: 4px;
}

/* Estilos para select múltiple */
select[multiple] {
    height: auto;
    min-height: 100px;
    padding: 8px;
}

select[multiple] option {
    padding: 8px;
    margin: 2px 0;
    border-radius: 4px;
}

select[multiple] option:checked {
    background: #e8f0fe linear-gradient(0deg, #e8f0fe 0%, #e8f0fe 100%);
    color: #1a73e8;
}

/* Personalización del scrollbar */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>
{% endblock %}

{% block scripts %}
<!-- Cargamos Awesomplete y Plotly -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.css">
<script src="https://cdn.jsdelivr.net/npm/awesomplete@1.1.5/awesomplete.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/css/select2.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/select2@4.0.13/dist/js/select2.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  initializeDates();
  setupProductSearch();
  setupForm();
  setupDownloadButton();
  setupBrandChange();
});

/**
 * Inicializa las fechas por defecto (start: hace 30 días, end: hoy)
 */
 function initializeDates() {
  const today = new Date();
  
  // Fecha fija: 01/01/2022
  const startDate = '2022-01-01';

  // Fecha de fin: Fecha actual
  const endDate = today.toISOString().split('T')[0];

  document.getElementById('start_date').value = startDate;
  document.getElementById('end_date').value = endDate;
}


document.addEventListener('DOMContentLoaded', function() {
  $('#brand').select2({
    placeholder: "Selecciona una o más marcas",
    allowClear: true
  });

  $('#store').select2({
    placeholder: "Selecciona una o más tiendas",
    allowClear: true
  });
});


/**
 * Configura Awesomplete para el input de producto.
 * Al seleccionar un producto, actualiza el select de marcas usando el endpoint.
 */
function setupProductSearch() {
  const searchInput = document.getElementById('product_search');
  const hiddenInput = document.getElementById('product_name');
  
  let products = {{ products|tojson|safe }};
  let uniqueProducts = Array.from(new Set(products));
  
  let awesomplete = new Awesomplete(searchInput, {
    minChars: 1,
    maxItems: 10,
    autoFirst: true,
    list: uniqueProducts
  });

  searchInput.addEventListener('awesomplete-selectcomplete', function() {
    hiddenInput.value = searchInput.value;
    // Actualiza marcas para el producto seleccionado
    const productName = searchInput.value;
    fetch(`/get_brands_for_product?product_name=${encodeURIComponent(productName)}`)
      .then(response => response.json())
      .then(data => {
        updateBrandSelect(data.brands);
        // También actualiza presentaciones (usando todas las marcas disponibles inicialmente)
        updatePresentationSelect(data.presentations);
      })
      .catch(error => console.error('Error al obtener marcas:', error));
  });
}

/**
 * Actualiza el select de marcas con la lista recibida y lo habilita para selección múltiple.
 */
function updateBrandSelect(brands) {
  const brandSelect = document.getElementById('brand');
  // Limpia el select y agrega la opción "Todas"
  brandSelect.innerHTML = '<option value="all">Todas</option>';
  brands.forEach(brand => {
    const option = document.createElement('option');
    option.value = brand;
    option.textContent = brand;
    brandSelect.appendChild(option);
  });
}

/**
 * Actualiza el select de presentaciones con la lista recibida.
 */
function updatePresentationSelect(presentations) {
  const presentationSelect = document.getElementById('presentation');
  presentationSelect.innerHTML = '<option value="all">Todas</option>';
  presentations.forEach(pres => {
    const option = document.createElement('option');
    option.value = pres;
    option.textContent = pres;
    presentationSelect.appendChild(option);
  });
}

/**
 * Escucha los cambios en el select de marcas (múltiple) para actualizar presentaciones.
 * Cuando cambian las marcas seleccionadas, se envía una petición para obtener las presentaciones vinculadas.
 */
function setupBrandChange() {
  const brandSelect = document.getElementById('brand');
  brandSelect.addEventListener('change', function() {
    const selectedOptions = Array.from(brandSelect.selectedOptions).map(opt => opt.value);
    const productName = document.getElementById('product_name').value;
    
    // Si se selecciona "all" o no se selecciona nada, usamos todas las presentaciones disponibles
    if (selectedOptions.length === 0 || selectedOptions.includes('all')) {
      // Se puede recargar las presentaciones del endpoint de marcas para el producto
      fetch(`/get_brands_for_product?product_name=${encodeURIComponent(productName)}`)
        .then(response => response.json())
        .then(data => {
          updatePresentationSelect(data.presentations);
        })
        .catch(error => console.error('Error al actualizar presentaciones:', error));
    } else {
      // Si se seleccionan múltiples marcas, se unen con comas
      const brandsParam = selectedOptions.join(',');
      fetch(`/get_presentations?product_name=${encodeURIComponent(productName)}&brands=${encodeURIComponent(brandsParam)}`)
        .then(response => response.json())
        .then(data => {
          updatePresentationSelect(data.presentations);
        })
        .catch(error => console.error('Error al actualizar presentaciones:', error));
    }
  });
}

/**
 * Maneja el envío del formulario para generar el gráfico
 */
function setupForm() {
  const form = document.getElementById('graphForm');
  form.addEventListener('submit', async function(event) {
    event.preventDefault();
    const formData = new FormData(this);
    if (formData.get('start_date') > formData.get('end_date')) {
      showError('La fecha de inicio no puede ser mayor a la fecha de fin.');
      return;
    }
    const loadingMessage = document.getElementById('loadingMessage');
    const graphDiv = document.getElementById('graphDiv');
    try {
      loadingMessage.style.display = 'block';
      graphDiv.style.display = 'none';
      const response = await fetch('/generate_graph', { method: 'POST', body: formData });
      if (response.redirected && response.url.includes('/login')) {
        showError('Debe iniciar sesión para generar gráficos. Redirigiendo...');
        setTimeout(() => { window.location.href = response.url; }, 2000);
        return;
      }
      const data = await response.json();
      if (!response.ok) { throw new Error(data.error || 'Error en la respuesta del servidor'); }
      loadingMessage.style.display = 'none';
      graphDiv.style.display = 'block';
      createPlot(data);
      document.getElementById('downloadButton').style.display = 'block';
    } catch (error) {
      console.error('Error:', error);
      showError(error.message);
      loadingMessage.style.display = 'none';
    }
  });
}

/**
 * Configura el botón de descarga de imagen del gráfico
 */
function setupDownloadButton() {
  document.getElementById('downloadButton').addEventListener('click', function() {
    Plotly.downloadImage('graphDiv', {
      format: 'png',
      filename: 'grafico',
      width: 1200,
      height: 800,
      scale: 2
    });
  });
}

/**
 * Función para crear el gráfico (utiliza Plotly)
 */
function createPlot(data) {
  if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {
    showError('No hay datos para graficar');
    return;
  }
  // Paleta de colores
  const colors = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
    '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
    '#393b79', '#637939', '#8c6d31', '#843c39', '#7b4173',
    '#17becf', '#e7969c', '#6b6ecf', '#b5cf6b', '#cedb9c',
    '#bd9e39', '#ad494a', '#d6616b', '#e7cb94', '#8ca252',
    '#d6616b', '#a55194', '#ce6dbd', '#de9ed6', '#9c9ede'
  ];
  const traces = [];
  let allPrices = [];

  data.data.forEach((item, index) => {
    // Si el item tiene 'line' y 'mode', es la línea de regresión.
    // De lo contrario, es una serie normal.
    const isRegression = (item.line && item.mode === 'lines');

    // Recopilamos precios para calcular min y max
    allPrices = allPrices.concat(item.prices);

    // Asignar configuración para cada serie
    let traceConfig = {
      x: item.dates,
      y: item.prices,
      name: item.label,
      hoverinfo: 'none'
    };

    if (isRegression) {
      // Usamos el estilo que viene desde el backend
      traceConfig.mode = item.mode;            // 'lines'
      traceConfig.line = item.line;            // { color: 'red', dash: 'dot', width: 3 }
    } else {
      // Es una serie normal
      traceConfig.mode = 'lines+markers';
      traceConfig.marker = {
        size: 8,
        color: colors[index % colors.length],
        line: { color: 'black', width: 1 }
      };
      traceConfig.line = { width: 2 };
    }

    traces.push(traceConfig);
  });

  const minPrice = Math.min(...allPrices);
  const maxPrice = Math.max(...allPrices);
  const priceRange = maxPrice - minPrice;
  const margin = priceRange * 0.1;
  const yMin = Math.max(0, minPrice - margin);
  const yMax = maxPrice + margin;
  const layout = {
    title: { text: data.title, font: { size: 24 } },
    xaxis: { title: 'Fecha', tickangle: -45, automargin: true, showline: true, linecolor: 'black', linewidth: 2, gridcolor: '#e0e0e0' },
    yaxis: { title: 'Precio', tickformat: priceRange < 0.1 ? '.3f' : '.2f', automargin: true, showline: true, linecolor: 'black', linewidth: 2, range: [yMin, yMax], nticks: priceRange < 0.1 ? 5 : 8, gridcolor: '#e0e0e0' },
    showlegend: true,
    legend: { x: 0, y: -0.3, orientation: 'h', yanchor: 'top', xanchor: 'left' },
    hovermode: 'closest',
    margin: { l: 100, r: 50, t: 100, b: 150 },
    plot_bgcolor: 'white',
    paper_bgcolor: 'white',
    autosize: true,
    height: 700
  };
  const config = {
    responsive: true,
    displayModeBar: true,
    displaylogo: false,
    modeBarButtonsToRemove: ['lasso2d','select2d']
  };
  Plotly.newPlot('graphDiv', traces, layout, config).then(function(gd) {
    gd.on('plotly_hover', function(eventData) {
      const date = eventData.points[0].x;
      const pointsAtDate = [];
      gd.data.forEach(trace => {
        const pointIndex = trace.x.indexOf(date);
        if (pointIndex !== -1) {
          pointsAtDate.push({ store: trace.name, price: trace.y[pointIndex] });
        }
      });
      if (pointsAtDate.length === 0) return;
      pointsAtDate.sort((a, b) => b.price - a.price);
      const dateObj = new Date(date);
      const dateStr = dateObj.toLocaleDateString('es-VE', { year: 'numeric', month: 'long', day: 'numeric' });
      let content = `<div style="font-weight:bold; padding-bottom:5px; margin-bottom:5px; border-bottom:1px solid #ccc;">${dateStr}</div>`;
      pointsAtDate.forEach(point => {
        const decimals = priceRange < 0.1 ? 3 : 2;
        content += `<div style="padding:2px 0;">${point.store}: Bs. ${point.price.toFixed(decimals)}</div>`;
      });
      const tooltip = document.getElementById('customTooltip');
      tooltip.innerHTML = content;
      tooltip.style.cssText = `
        display: block;
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 8px;
        font-size: 12px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 1000;
        pointer-events: none;
        min-width: 200px;
      `;
      let x = eventData.event.pageX + 10;
      let y = eventData.event.pageY + 10;
      const rect = tooltip.getBoundingClientRect();
      if (x + rect.width > window.innerWidth) { x = eventData.event.pageX - rect.width - 10; }
      if (y + rect.height > window.innerHeight) { y = eventData.event.pageY - rect.height - 10; }
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
      Plotly.relayout(gd, {
        shapes: [{
          type: 'line',
          x0: date,
          x1: date,
          xref: 'x',
          yref: 'paper',
          y0: 0,
          y1: 1,
          line: { dash: 'dot', color: 'red', width: 2 }
        }]
      });
    });
    gd.on('plotly_unhover', function() {
      document.getElementById('customTooltip').style.display = 'none';
      Plotly.relayout(gd, { shapes: [] });
    });
    setTimeout(() => { Plotly.Plots.resize(gd); }, 100);
  });
}

/**
 * Muestra un mensaje de error en la parte superior
 */
function showError(message) {
  const errorContainer = document.getElementById('errorContainer');
  const errorMessage = document.getElementById('errorMessage');
  errorMessage.textContent = message;
  errorContainer.style.display = 'block';
  setTimeout(() => { errorContainer.style.display = 'none'; }, 5000);
}
</script>
{{ super() }}
{% endblock %}

























