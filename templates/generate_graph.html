{% extends "base.html" %}

{% block title %}Generar Gráfico{% endblock %}

{% block content %}
<!-- Mantener el mismo contenido del form y contenedores -->
{{ super() }}
{% endblock %}

{% block scripts %}
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  console.log("Página generate_graph cargada.");
  initializeDates();
  setupDownloadButton();
});

function initializeDates() {
  const today = new Date().toISOString().split("T")[0];
  document.getElementById("end_date").value = today;
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  document.getElementById("start_date").value = thirtyDaysAgo.toISOString().split("T")[0];
}

function setupDownloadButton() {
  const downloadButton = document.getElementById("downloadButton");
  if (downloadButton) {
    downloadButton.addEventListener("click", function() {
      Plotly.downloadImage("graphDiv", {
        format: "png",
        filename: "grafico",
        width: 1200,
        height: 800
      }).then(() => {
        console.log("Imagen descargada.");
      }).catch((err) => {
        console.error("Error al descargar la imagen:", err);
      });
    });
  }
}

function showError(message) {
  console.error("Error:", message);
  const errorContainer = document.getElementById("errorContainer");
  const errorMessage = document.getElementById("errorMessage");
  errorMessage.textContent = message;
  errorContainer.style.display = "block";
  setTimeout(() => {
    errorContainer.style.display = "none";
  }, 5000);
}

async function handleSubmit(event) {
  event.preventDefault();
  console.log("handleSubmit disparado!");

  const form = document.getElementById("graphForm");
  const graphContainer = document.getElementById("graphContainer");
  const loadingMessage = document.getElementById("loadingMessage");
  const graphDiv = document.getElementById("graphDiv");

  try {
    // Validar fechas
    const formData = new FormData(form);
    if (formData.get("start_date") > formData.get("end_date")) {
      showError("La fecha de inicio no puede ser mayor a la fecha de fin.");
      return false;
    }

    // Mostrar estado de carga
    graphContainer.style.display = "block";
    loadingMessage.style.display = "block";
    graphDiv.style.display = "none";

    // Obtener datos
    const response = await fetch(form.action, {
      method: "POST",
      body: formData
    });
    const data = await response.json();
    console.log("Datos recibidos:", data);

    if (!response.ok || data.error) {
      throw new Error(data.error || "Error en la respuesta de /graph");
    }

    // Preparar visualización
    loadingMessage.style.display = "none";
    graphDiv.style.display = "block";

    // Configurar colores
    const colors = [
      '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
      '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
    ];

    // Construir trazas
    const traces = data.data.map((item, index) => ({
      x: item.dates,
      y: item.prices,
      mode: "lines+markers",
      name: item.label,
      line: { color: colors[index % colors.length] },
      marker: { size: 10, color: colors[index % colors.length] },
      hoverinfo: "none"  // Desactivamos el hover por defecto
    }));

    // Configurar layout
    const layout = {
      title: data.title,
      xaxis: { 
        title: "Fecha", 
        tickangle: -45,
        automargin: true
      },
      yaxis: { 
        title: "Precio",
        tickformat: ".2f"
      },
      showlegend: true,
      legend: {
        x: 0,
        y: -0.5,
        orientation: "h",
        yanchor: "top"
      },
      hovermode: "closest",
      margin: {
        l: 80,
        r: 50,
        t: 100,
        b: 200
      }
    };

    // Configurar opciones
    const config = {
      responsive: true,
      displayModeBar: true,
      displaylogo: false
    };

    // Crear gráfico
    Plotly.newPlot("graphDiv", traces, layout, config).then(function(gd) {
      // Manejar eventos de hover
      gd.on("plotly_hover", function(eventData) {
        if (!eventData.points || eventData.points.length === 0) return;

        const xValue = eventData.points[0].x;
        const pointsAtX = [];

        // Recolectar todos los puntos para esta fecha
        gd.data.forEach(trace => {
          const xIndex = trace.x.indexOf(xValue);
          if (xIndex !== -1) {
            pointsAtX.push({
              store: trace.name,
              price: trace.y[xIndex]
            });
          }
        });

        // Ordenar por precio
        pointsAtX.sort((a, b) => a.price - b.price);

        // Formatear fecha
        const date = new Date(xValue);
        const dateStr = date.toLocaleDateString('es-VE', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });

        // Construir tooltip
        let content = `<div style="font-weight: bold; margin-bottom: 5px;">${dateStr}</div>`;
        pointsAtX.forEach(point => {
          content += `<div>${point.store}: Bs. ${point.price.toFixed(2)}</div>`;
        });

        // Mostrar tooltip
        const tooltip = document.getElementById("customTooltip");
        tooltip.innerHTML = content;
        tooltip.style.display = "block";

        // Posicionar tooltip
        let x = eventData.event.clientX + 10;
        let y = eventData.event.clientY + 10;

        // Ajustar si se sale de la pantalla
        const rect = tooltip.getBoundingClientRect();
        if (x + rect.width > window.innerWidth) {
          x = eventData.event.clientX - rect.width - 10;
        }
        if (y + rect.height > window.innerHeight) {
          y = eventData.event.clientY - rect.height - 10;
        }

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";
      });

      // Ocultar tooltip cuando el mouse sale
      gd.on("plotly_unhover", function() {
        document.getElementById("customTooltip").style.display = "none";
      });
    });

  } catch (error) {
    loadingMessage.style.display = "none";
    showError("Error al generar el gráfico: " + error.message);
  }

  return false;
}
</script>
{% endblock %}
